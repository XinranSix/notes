![0B319B38-B70E-4118-B897-74EFA7E368F9](https://github.com/XinranSix/docs/assets/62458905/71546103-e328-4cbb-ae49-126208452285)

[toc]

## 排序算法概述

对排序严格点得到定义是：假设含有 $n$ 个记录的序列为 $\left\{r_1, r_2, \cdots, r_n\right\}$，其相对应的关键字分别为：$\left\{k_1, k_2, \cdots, k_n\right\}$，需确定 $1,2,3,\cdots,n$ 的一种排列 $p_1,p_2,\cdots,p_n$，使其相应的关键字满足 $k_{p_1} \leqslant k_{p_2} \leqslant \cdots \leqslant k_{p_n}$ 非递减（或非递增）关系，即使得序列成为一个按关键字有序的序列：$\left\{r_{p_1},r_{p_2},\cdots,r_{p_n}\right\}$，这样的操作就成为排序。

 排序算法的稳定性：对于一个排序算法，假设 $k_i=k_j \left(1\leqslant i \leqslant n, 1\leqslant j\leqslant n,i \neq j\right)$，且在排序前的序列中 $r_i$ 领先于 $r_j$（即 $i \lt j$）。如果排序后 $r_i$ 仍领先于 $r_j$，则称所用的排序算法是稳定的，否则是不稳定的

排序可分为**内排序**与**外排序**，内排序在排序过程中数据全部放置在内存中，外排序由于数据太对，不能将数据一次性加载在内存中，在排序过程中需要多次在内外存直接交换数据。

十种常见排序算法可以分为两大类：

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 $\Omicron \left(n \log n\right)$，因此也称为非线性时间比较类排序。
- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。

对于排序算法的评价也是从时间和空间的角度出发，即排序的时间和所用的额外空间。排序算法的时间开销主要由比较和移动产生。额外空间的产生是因为有些算法需要借助辅助空间才能完成。

本文会介绍冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、桶排序、计数排序和基数排序，其中冒泡排序、选择排序和插入排序是简单的排序算法，希尔排序、归并排序、堆排序、快速快速排序是改进算法，其他的算法属于特殊手段。

## 冒泡排序

冒泡排序是一种简单的排序算法。它重复地遍历要排序的数组，一次比较两个元素，如果它们逆序就把它们交换过来。遍历数组的工作是重复地进行直到没有再需要交换的相邻元素，也就是说该数组已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢「浮」到数组的后面。

![v2-33a947c71ad62b254cab62e5364d2813_b](https://github.com/XinranSix/Computer-Graphics/assets/62458905/eb2cea36-58d0-4622-9856-b1bcce77093c)

代码如下：

```cpp
void bubble_sort(int *arr, int n) {
    for (int i = n - 1; i > 0; --i) {
        for (int j = 0; j < i; ++j) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

实际上如果在某一轮中没有进行交换操作，则说明数组已经有序，所以此时可结束排序，可利用这一点进行代码优化，优化后的代码如下：

```cpp
void bubble_sort(int *arr, int n) {
    bool flag = false;
    for (int i = n - 1; i > 0; --i) {
        for (int j = 0; j < i; ++j) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                flag = true;
            }
        }
        if (!flag) {
            break;
        }
    }
}

```

复杂度分析：对于改进后的算法，最好的情况是数组本来就是有序的，只是进行了 $n - 1$ 次的比较，所以复杂度为 $\Omicron \left(n\right)$；最坏的情况就是数组是逆序的时候，此时比较次数为：
$$
\sum_{i=2}^{n} = \frac{n \left(n - 1\right)}{n}
$$
在相邻元素相等时，不交换他们的位置可保证算法是稳定的算法。

## 选择排序

## 插入排序

## 希尔排序

## 归并排序

## 快速排序

## 堆排序

## 桶排序

## 计数排序

## 基数排序

## 参考

- [Wikipedia | Sorting algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm)
- [维基百科 | 排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)
- [[算法总结] 十大排序算法 | vivia](https://zhuanlan.zhihu.com/p/42586566)
- [十大经典排序算法（动图演示）| 一像素 | 博客园](https://www.cnblogs.com/onepixel/articles/7674659.html)
- [十大经典排序算法 | 菜鸟教程](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)
- [十大经典排序算法动画与解析，看我就够了！（配代码完全版） | Github | MisterBooo](https://github.com/MisterBooo/Article)
- [十大经典排序算法整理汇总 | X-lab](http://www.x-lab.info/post/sort-algorithm/)
- [十大经典排序算法详解 | 卢明冬 | 卢明冬的博客](https://lumingdong.cn/detailed-explanation-of-ten-classic-sorting-algorithms.html)
- 算法导论
- 大话数据结构