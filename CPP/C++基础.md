[TOC]

## C++ 关键字

|            |              |                  |             |          |
| ---------- | ------------ | ---------------- | ----------- | -------- |
| asm        | do           | if               | return      | typedef  |
| auto       | double       | inline           | short       | typeid   |
| bool       | dynamic_cast | int              | signed      | typename |
| break      | else         | long             | sizeof      | union    |
| case       | enum         | mutable          | static      | unsigned |
| catch      | explicit     | namespace        | static_cast | using    |
| char       | export       | new              | struct      | virtual  |
| class      | extern       | operator         | switch      | void     |
| const      | false        | private          | template    | volatile |
| const_cast | float        | protected        | this        | wchar_t  |
| continue   | for          | public           | throw       | while    |
| default    | friend       | register         | true        |          |
| delete     | goto         | reinterpret_cast | try         |          |

> 在定义标识符时不要使用这些关键字。

## const 关键字

### 定义常量

定义常量有两种方式，一种是宏定义，另外一种是使用 `const` 关键字，定义格式如下：

```cpp
const 数据类型 常量名 = 常量值;
```

### 指针与 const

const 修饰指针有三种情况

1. `const int * p = &a;`：常量指针，指针指向可以改变，指针指向的值不可以更改变。
2. `int const * p = &a;`：指针常量，指针指向不可以改变，指针指向的值可以更改变。
3. `const int const * p = &a;`

## 数据类型

### sizeof 关键字

`sizeof` 关键字可以统计数据类型所占内存大小。使用方式如下：

```cpp
sizeof(数据类型/变量);
```

### 整型

C++ 中有 4 中整型类型，如下表所示。

|  数据类型   |                           占用空间                           |        取值范围         |
| :---------: | :----------------------------------------------------------: | :---------------------: |
|   `short`   |                            2 字节                            | $-2^{15} \sim 2^{15}-1$ |
|    `int`    |                            4 字节                            | $-2^{31} \sim 2^{31}-1$ |
|   `long`    | Windows 为 4 字节，Linux 为 4 字节（32 位），8 字节（64 位） | $-2^{31} \sim 2^{31}-1$ |
| `long long` |                            8 字节                            | $-2^{63} \sim 2^{63}-1$ |

> 整型占用空间大小：short < int <= long <= long long

### 实型（浮点型）

C++ 中有两种实型：`float` 和 `double`

| 数据类型 | 占用空间 |    有效数字范围     |
| :------: | :------: | :-----------------: |
| `float`  |  4 字节  |    7 位有效数字     |
| `double` |  8 字节  | 15 ～ 16 位有效数字 |

> C++ 中的浮点数字面量默认是 double 类型，想要表示 float 类似的字面量应该这样表示：`3.14f`。
> C++ 中的浮点数还可以使用科学计数法，例如：`3e2` 表示 $3 \times 10 ^ {2}$，`3e-2` 表示 $3 \times 10 ^ {-2}$。

### 字符型

语法：`char ch = 'a';`

> 注意 1：在显示字符型变量时，用单引号将字符括起来，不要用双引号。
> 注意 2：单引号内只能有一个字符，不可以是多个字符。

-   C 和 C++ 中字符型变量只占用 1 个字节。
-   字符型变量并不是把字符本身放到内存中存储，而是将对应的 ASCII 编码放入到存储单元。

示例：

```cpp
int main() {

	char ch = 'a';
	cout << ch << endl;
	cout << sizeof(char) << endl;

	cout << (int)ch << endl;  //查看字符a对应的ASCII码
	ch = 97; //可以直接用ASCII给字符型变量赋值
	cout << ch << endl;

	return 0;
}
```

ASCII 码表格：

| ASCII 值 | 控制字符 | ASCII 值 |  字符   | ASCII 值 | 字符 | ASCII 值 | 字符 |
| :------: | :------: | :------: | :-----: | :------: | :--: | :------: | :--: |
|    0     |   NUT    |    32    | (space) |    64    |  @   |    96    |  、  |
|    1     |   SOH    |    33    |    !    |    65    |  A   |    97    |  a   |
|    2     |   STX    |    34    |    "    |    66    |  B   |    98    |  b   |
|    3     |   ETX    |    35    |    #    |    67    |  C   |    99    |  c   |
|    4     |   EOT    |    36    |    $    |    68    |  D   |   100    |  d   |
|    5     |   ENQ    |    37    |    %    |    69    |  E   |   101    |  e   |
|    6     |   ACK    |    38    |    &    |    70    |  F   |   102    |  f   |
|    7     |   BEL    |    39    |    ,    |    71    |  G   |   103    |  g   |
|    8     |    BS    |    40    |    (    |    72    |  H   |   104    |  h   |
|    9     |    HT    |    41    |    )    |    73    |  I   |   105    |  i   |
|    10    |    LF    |    42    |   \*    |    74    |  J   |   106    |  j   |
|    11    |    VT    |    43    |    +    |    75    |  K   |   107    |  k   |
|    12    |    FF    |    44    |    ,    |    76    |  L   |   108    |  l   |
|    13    |    CR    |    45    |    -    |    77    |  M   |   109    |  m   |
|    14    |    SO    |    46    |    .    |    78    |  N   |   110    |  n   |
|    15    |    SI    |    47    |    /    |    79    |  O   |   111    |  o   |
|    16    |   DLE    |    48    |    0    |    80    |  P   |   112    |  p   |
|    17    |   DCI    |    49    |    1    |    81    |  Q   |   113    |  q   |
|    18    |   DC2    |    50    |    2    |    82    |  R   |   114    |  r   |
|    19    |   DC3    |    51    |    3    |    83    |  S   |   115    |  s   |
|    20    |   DC4    |    52    |    4    |    84    |  T   |   116    |  t   |
|    21    |   NAK    |    53    |    5    |    85    |  U   |   117    |  u   |
|    22    |   SYN    |    54    |    6    |    86    |  V   |   118    |  v   |
|    23    |    TB    |    55    |    7    |    87    |  W   |   119    |  w   |
|    24    |   CAN    |    56    |    8    |    88    |  X   |   120    |  x   |
|    25    |    EM    |    57    |    9    |    89    |  Y   |   121    |  y   |
|    26    |   SUB    |    58    |    :    |    90    |  Z   |   122    |  z   |
|    27    |   ESC    |    59    |    ;    |    91    |  [   |   123    |  {   |
|    28    |    FS    |    60    |    <    |    92    |  /   |   124    |  \|  |
|    29    |    GS    |    61    |    =    |    93    |  ]   |   125    |  }   |
|    30    |    RS    |    62    |    >    |    94    |  ^   |   126    |  \`  |
|    31    |    US    |    63    |    ?    |    95    |  \_  |   127    | DEL  |

ASCII 码大致由以\*两部分组成：

-   ASCII 非打印控制字符：ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。
-   ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。

#### 转义字符

通过转义字符可以表示一些不能显示出来的 ASCII 字符，例如：`'\n'`、`'\\'`，`'\t'`。

| 转义字符 |                   含义                   | ASCII 码值（十进制） |
| :------: | :--------------------------------------: | :------------------: |
|    \a    |                   警报                   |         007          |
|    \b    |    退格（BS） ，将当前位置移到前一列     |         008          |
|    \f    |    换页（FF），将当前位置移到下页开头    |         012          |
|    \n    |   换行（LF），将当前位置移到下一行开头   |         010          |
|    \r    |   回车（CR） ，将当前位置移到本行开头    |         013          |
|    \t    |   水平制表（HT，跳到下一个 TAB 位置）    |         009          |
|    \v    |              垂直制表（VT)               |         011          |
|   \\\\   |        代表一个反斜线字符（`\`）         |         092          |
|    \'    |        代表一个单引号（撇号）字符        |         039          |
|    \"    |            代表一个双引号字符            |         034          |
|    \?    |               代表一个问号               |         063          |
|    \0    |                  数字 0                  |         000          |
|   \ddd   |       8 进制转义字符，d 范围 0\~7        |     3 位 8 进制      |
|   \xhh   | 16 进制转义字符，h 范围 0\~9，a\~f，A\~F |     3 位 16 进制     |

### 字符串型

在 C++中可以使用两种风格的字符串，一种是像 C 语言中那样使用字符数组来表示字符串，还有一种是使用 C++ STL 中的 `string`。

-   C 风格字符串：`char 变量名[] = "字符串值";`
-   C++ 风格字符串：`string 变量名 = "字符串值";`

> 字符串字面量要用双引号括起来。
> C++风格字符串，需要加入头文件 `#include<string>`。

### 布尔类型 bool

C++ 中引入的一种新的数据类型，表示真假，只有两个值：`true` 和 `false`，true 本质是 1，false 本质是 0。在 C++ 中，依然可以使用 0 表示 fasle，非 0 表示 true。

> bool 类型占 1 个字节大小

## 数组

### 一维数组

一维数组定义的三种方式：

1. `数据类型 数组名[数组长度];`
2. `数据类型 数组名[数组长度] = { 值1，值2 ...};`
3. `数据类型 数组名[] = { 值1，值2 ...};`

一维数组名称一方面表示数组在内存中的首地址，另外一方面可以通过一维数组名称统计整个数组在内存中的长度，方式为：`sizeof(arr) / sizeof(arr[0])`。

> 注意：数组名是常量，不可以赋值。
> 将数组名作为函数参数传递时，数组会退化成指向第一个元素的指针，实际上，很多时候我们都可以将数组名视为指向数组中第一个元素的指针。

### 二维数组

二维数组定义的四种方式：

1. `数据类型 数组名[行数][列数];`
2. `数据类型 数组名[行数 [列数] = { {数据1，数据2 } ，{数据3，数据4 } };`
3. `数据类型 数组名[行数][列数] = { 数据1，数据2，数据3，数据4};`
4. ` 数据类型 数组名[][列 ] = { 数据1，数据2，数据3，数据4};`

## 结构体

结构体的定义：`struct 结构体名 { 结构体成员列表 };`

通过结构体创建变量的方式有三种：

-   `struct 结构体名 变量名;`
-   `struct 结构体名 变量名 = { 成员 1 值 ， 成员 2 值...};`
-   定义结构体时顺便创建变量。

## 内存分区模型

C++程序在执行时，将内存大方向划分为 4 个区域：

-   代码区：存放函数体的二进制代码，由操作系统进行管理的。
-   全局区：存放全局变量和静态变量以及常量。
-   栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等。
-   堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收（`new` 出来的东西都在堆区）。

> 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程。

### 程序运行前

在程序编译后，生成了 exe 可执行程序，未执行该程序前分为两个区域：

-   代码区：
    -   存放 CPU 执行的机器指令。
    -   代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。
    -   代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令。
-   全局区：
    -   全局变量和静态变量存放在此。
    -   全局区还包含了常量区, 字符串常量和其他常量也存放在此。
    -   该区域的数据在程序结束后由操作系统释放。

示例：

```cpp
//全局变量
int g_a = 10;
int g_b = 10;

//全局常量
const int c_g_a = 10;
const int c_g_b = 10;

int main() {

	//局部变量
	int a = 10;
	int b = 10;

	//打印地址
	cout << "局部变量a地址为： " << (int)&a << endl;
	cout << "局部变量b地址为： " << (int)&b << endl;

	cout << "全局变量g_a地址为： " <<  (int)&g_a << endl;
	cout << "全局变量g_b地址为： " <<  (int)&g_b << endl;

	//静态变量
	static int s_a = 10;
	static int s_b = 10;

	cout << "静态变量s_a地址为： " << (int)&s_a << endl;
	cout << "静态变量s_b地址为： " << (int)&s_b << endl;

	cout << "字符串常量地址为： " << (int)&"hello world" << endl;
	cout << "字符串常量地址为： " << (int)&"hello world1" << endl;

	cout << "全局常量c_g_a地址为： " << (int)&c_g_a << endl;
	cout << "全局常量c_g_b地址为： " << (int)&c_g_b << endl;

	const int c_l_a = 10;
	const int c_l_b = 10;
	cout << "局部常量c_l_a地址为： " << (int)&c_l_a << endl;
	cout << "局部常量c_l_b地址为： " << (int)&c_l_b << endl;

	return 0;
}
```

打印结果：

![1545017602518](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/8919/1545017602518.png)

### 程序运行后

-   栈区
    -   由编译器自动分配释放，存放函数的参数值，局部变量。
    -   等注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。
-   堆区：
    -   由程序员分配释放，若程序员不释放，程序结束时由操作系统回收。
    -   在 C++ 中主要利用 new 在堆区开辟内存。

### new 操作符

C++中利用 new 操作符在堆区开辟数据。

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete。

语法：`new 数据类型`。

利用 new 创建的数据，会返回该数据对应的类型的指针

示例 1：

```cpp
int* func()
{
	int* a = new int(10);
	return a;
}

int main() {

	int *p = func();

	cout << *p << endl;
	cout << *p << endl;

	//利用delete释放堆区数据
	delete p;

	//cout << *p << endl; //报错，释放的空间不可访问

	system("pause");

	return 0;
}
```

示例 2：开辟数组

```cpp
//堆区开辟数组
int main() {

	int* arr = new int[10];

	for (int i = 0; i < 10; i++)
	{
		arr[i] = i + 100;
	}

	for (int i = 0; i < 10; i++)
	{
		cout << arr[i] << endl;
	}
	//释放数组 delete 后加 []
	delete[] arr;

	system("pause");

	return 0;
}

```

## 引用

### 2.1 引用的基本使用

语法：`数据类型 &别名 = 原名;`

> 引用必须初始化。
>
> 引用在初始化后，指向不可改变。
>
> 引用的本质在 C++ 内部实现是一个指针常量。

## 函数

### 指针与函数

利用指针作函数参数，可以修改实参的值。

示例：

```cpp
//值传递
void swap1(int a ,int b)
{
	int temp = a;
	a = b;
	b = temp;
}

//地址传递
void swap2(int * p1, int *p2)
{
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

int main() {

	int a = 10;
	int b = 20;
	swap1(a, b); // 值传递不会改变实参

	swap2(&a, &b); //地址传递会改变实参

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;

	system("pause");
	return 0;
}
```

> 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递。

### 引用与函数

引用做函数参数：函数传参时，可以利用引用的技术让形参修饰实参。

引用做函数返回值：引用是可以作为函数的返回值。

> 通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单。
>
> 不要返回局部变量引用。
>
> 返回引用的函数可以作为左值。
>
> 函数声明引用参数时，可以加上 `const` 关键字，这样在函数内部只有对该变量的读权限，没有写权限。

### 函数默认参数

在 C++ 中，函数的形参列表中的形参是可以有默认值的。

语法：` 返回值类型 函数名(参数= 默认值) {}`

1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值。
2. 如果函数声明有默认值，函数实现的时候就不能有默认参数。

### 函数占位参数

C++ 中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置。

语法：`返回值类型 函数名(数据类型 ){}`

示例：

```cpp
// 函数占位参数 ，占位参数也可以有默认参数
void func(int a, int) {
	cout << "this is func" << endl;
}

int main() {

	func(10,10); //占位参数必须填补

	system("pause");
	return 0;
}
```

### 函数重载

函数名可以相同，提高复用性。

函数重载满足条件：

-   同一个作用域下；
-   函数名称相同；
-   函数参数类型不同或者个数不同或者顺序不同。

> 函数的返回值不可以作为函数重载的条件。

#### 函数重载注意事项

-   引用作为重载条件，字面量会优先调用参数带 `const` 关键字的函数，变量会优先调用参数无 `const` 关键字的函数。
-   函数重载碰到函数默认参数时会参数歧义，请避免这种用法。

