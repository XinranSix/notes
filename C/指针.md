## 内存相关概念

**外存：**又称拓展存储器，长期存放数据，是可掉电的设备，常见的外存设备有：硬盘、flash、ROM、U 盘、光盘、磁带。

**内存：**暂时存放数据的设备，掉电丢失数据，厂家的内存有：RAM，DDR.

内存分为**物理内存**和虚拟内存。

- 物理内存：实实在在的存储设备；
- 虚拟内存：操作系统虚拟出来的内存。

操作系统会将虚拟内存和物理内存进行映射。

在 32 位操作系统下，每个进程的寻址范围位 `0x00000000~0xffffffff`，即 4G，我们在编程时看到的内存地址都是虚拟地址。

在程序运行时，操作系统会将**虚拟内存**进行分区：

- 堆：在动态申请内存时，会在堆区开辟空间；
- 栈：主要存放局部变量；
- 静态全局区：
  - 位初始化的静态全局区：没有初始化的静态变量（`static` 修饰的变量），或全局变量存放在此区；
  - 初始化了的静态全局区：初始化过的全局变量、静态变量存在此区。
- 代码区：存放代码的区；
- 文字常量区：存放常量的区；

## 指针的相关概念

> 本文均在 32 为平台上进行讨论。

系统给每个存储单元分配了一个编号，从 `0x00000000~0xffffffff`，这个编号就是地址。

> 指针就是地址。

![image](https://github.com/XinranSix/Computer-Graphics/assets/62458905/51a85890-ee89-4e25-9489-6545d4a5f796)

指针变量：一个存放地址编号的变量。

在 32 位平台下，地址总线是 32 位的，所以地址是 32 位编号，占用 4 个字节，所以在 32 位平台下指针变量占用 4 个字节。

> 鱼代表鱼，虾代表虾，乌龟代表是王八。对应指针变量只能存放对应类型变量的地址，例如 `int` 类型的指针只能存放 `int` 类型变量的地址。

`char` 占 1 个字节，它有一个地址编号，这个地址编号就是其地址；`int` 占 4 个字节，它占有 4 个字节的存储单元，有 4 个地址编号。

![image](https://github.com/XinranSix/Computer-Graphics/assets/62458905/67036c70-1ee8-4729-8dbf-3df54f568cd7)

## 指针的定义方法

定义指针的语法：

```c
数据类型 *指针变量名;
int *p;
int *p1, p2;
```

与指针相关的运算符：`&`、`*`.

`&` 是取地址运算符，`*` 是取值运算符。

![image](https://github.com/XinranSix/Computer-Graphics/assets/62458905/1139ce2c-7536-4c61-a440-9ed2d47bd911)

```c
#include <stdio.h>

int main(int argc, char *argv[]) {

    int a = 100;
    int *p;
    p = &a;

    printf("a = %d %d\n", a, *p);
    printf("&a = %p %p\n", &a, p);

    return 0;
}
```

输出结果为：

![image](https://github.com/XinranSix/Computer-Graphics/assets/62458905/921666e3-b0bc-40a4-8b5e-3577d2859315)

指针大小：在 32 位系统下，所有类型的指针都是 4 个字节。

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    char *a;
    short *b;
    int *c;
    long *d;
    float *e;
    double *f;

    printf("sizeof(a) = %lld\n", sizeof(a));
    printf("sizeof(b) = %lld\n", sizeof(b));
    printf("sizeof(c) = %lld\n", sizeof(c));
    printf("sizeof(d) = %lld\n", sizeof(d));
    printf("sizeof(e) = %lld\n", sizeof(e));
    printf("sizeof(f) = %lld\n", sizeof(f));

    return 0;
}
```

输出结果为：

![image](https://github.com/XinranSix/Computer-Graphics/assets/62458905/4c425eb6-d0c4-418d-be0a-5ac63d3b2ddc)

## 指针的分类

1. `char` 型指针；
2. `short int` 型指针；
3. `int` 指针；
4. `long` 指针；
5. `float` 型指针；
6. `double` 型指针；
7. 函数指针；
8. 结构体指针；
9. 指针的指针；
10. 数组指针。

> 不管是声明指针，在 32 位操作系统上，均占有 4 个字节。

## 指针和变量的关系

指针可以存放变量的地址。

在程序中，访问变量的值可以字节使用变量名，例如：

```c
int a;
a = 100;
```

也可以通过指针来访问变量的值：

```c
int *p;
p = &a;
*p = 100;
```

> 注意：
>
> 1. 指针在试用期一定要初始化。
> 2. 指针只能指向开辟好空间的地址，不能随意保存地址。

```c
#include <stdio.h>

int main(int argc, char *argv[]) {

    int *p1, *p2, temp, a, b;
    p1 = &a;
    p2 = &b;
    printf("请输入:a b的值:\n");
    scanf("%d %d", p1, p2); // 给p1和p2指向的变量赋值
    temp = *p1;             // 用p1指向的变量（a）给temp赋值
    *p1 = *p2;  // 用p2指向的变量（b）给p1指向的变量（a）赋值
    *p2 = temp; // temp给p2指向的变量（b）赋值
    printf("a=%d b=%d\n", a, b);
    printf("*p1=%d *p2=%d\n", *p1, *p2);

    return 0;
}
```

输出结果：

![image](https://github.com/XinranSix/docs/assets/62458905/e6af8b05-742b-47a4-b2b0-08926a1105d6)

> 注意：对应类型的指针，只能保持对应类型数据的地址，如果想让不同类型的指针互相赋值，需要强制类型转换。

```c
#include <stdio.h>

int main(int argc, char *argv[]) {

    int a = 0x1234, b = 0x5678;
    char *p1, *p2;
    printf("%#x %#x\n", a, b);
    p1 = (char *)&a;
    p2 = (char *)&b;
    printf("%#x %#x\n", *p1, *p2);
    p1++;
    p2++;
    printf("%#x %#x\n", *p1, *p2);

    return 0;
}
```

输出结果：

![image](https://github.com/XinranSix/docs/assets/62458905/a9cbbfec-00d8-43d2-afd0-8618d8d8ec3e)

> 注意：
>
> 1. 使用 `*` 对指针取值时，取几个字节，由指针类型决定，`int` 类型的指针取 4 个字节，`double` 类型的指针取 8 个字节。
> 2. 对指针进行 `+1` 操作时，指针会跳过若干字节，跳过的字节的大小有指针类型决定，例如 `int` 类型的指针会跳过 4 个字节。

## 指针和数组元素之间的关系

### 数组元素与指针的基本关系

变量存放在内存中，有自己的地址编号。数组时多个相同类型变量的集合，每个变量都占用内存空间，都有自己的内存编号，数组在内存中是连续存放的。

指针变量可以指向存放数组元素的地址。

```c
#include <stdio.h>

int main(int argc, char *argv[]) {

    int a[10];
    int *p;
    p = &a[0]; // 指针变量p保存了数组a中第0个元素的地址，即a[0]的地址

    return 0;
}
```

### 访问数组数组元素的方法

**方式 1：**`数组名[索引]`

```c
int a[10];
a[2] = 100;
```

**方式 2：**`指针名 + 下标`

```c
int a[10];
int *p;
p = a;
p[2] = 100;
```

> 在 C 语言中，数组名就是数组的首地址，即第 0 个元素的地址，是个常量。

> 注意：p 和 a 不同，p 是指针变量，而 a 是个常量。所以可以使用等号给 p 赋值，但不能给 a 赋值。例如：`int a[10]; a++;` 这种用法是错误的，因为 a 是数组名，是一种地址常量。

**方式 3：**通过指针运算加取值的方法来引用数组的元素

```c
int a[10];
int *p;
p = a;
*(p + 2) = 100;
```

`p` 是第  个元素的地址，`p + 2` 是 `a[2]` 这个元素的地址，对第二个元素的地址取值，即 `a[2]`。

```c
#include <stdio.h>

int main(int argc, char *argv[]) {

    int a[5] = {0, 1, 2, 3, 4};
    int *p = a;

    // 只要将数组名赋值给同类型的指针变量，则此时的指针变量与数组名可
    // 以用相同的方法操作数组
    printf("a[2]=%d\n", a[2]);
    printf("p[2]=%d\n", p[2]);

    //*(a + n) <==> *(p + n) <==> a[n] <==> p[n]
    printf("*(p+2) = %d\n", *(p + 2));
    printf("*(a+2) = %d\n", *(a + 2));

    printf("p=%p\n", p);
    printf("p+2=%p\n", p + 2);
    printf("&a[0] = %p\n", &a[0]);
    printf("&a[2] = %p\n", &a[2]);

    return 0;
}
```

输出结果：

![image](https://github.com/XinranSix/docs/assets/62458905/e1579dc7-a6f4-458f-b131-da3e6d227fc8)



## 指针的运算

### 指针可以加一个整数

往后指几个它指向的变量，结果还是个地址。

> 注意：一般来说，指针指向数组是加一个整数才有意义。

```c
#include <stdio.h>

int main() {
    
    int a[10];
    int *p, *q;
    // p和q间隔8个字节，意味着加一个整数最终移动的字节数与指针变量的类型也有关系
    p = a;
    q = p + 2;
    printf("p = %p\n", p);
    printf("q = %p\n", q);

    return 0;
}
```

![image](https://github.com/XinranSix/docs/assets/62458905/0796e556-3cb2-4464-9a0b-aba79d814d8f)

### 两个相同类型指针可以比较大小

> 注意：只有相同类型的指针指向同一个数组里的元素，比较大小才有意义。

指向前面元素的指针小于指向后面元素的指针。

```c
#include <stdio.h>

int main() {
    int a[10];
    int *p, *q;
    p = &a[1];
    q = &a[6];
    if (p < q) {
        printf("p < q\n");
    } else if (p > q) {
        printf("p > q\n");
    } else {
        printf("p = q\n");
    }
    return 0;
}
```

输出结果：

![image](https://github.com/XinranSix/docs/assets/62458905/70dfe7a9-6152-40fd-887a-5f883ed571c6)

### 两个相同类型的指针可以做减法

> 注意：只有相同类型的指针指向同一个数组里的元素，做减法才有意义。

做减法的结果是两个指针之间有多少个元素。

```c
#include <stdio.h>

int main() {

    int a[10];
    int *p, *q;
    p = &a[0];
    q = &a[3];
    printf("%lld\n", q - p);

    return 0;
}
```

输出结果：

![image](https://github.com/XinranSix/docs/assets/62458905/94c08063-3ba2-4c90-b368-5170dbafb76f)

### 两个相同类型的指针可以相互赋值

> 注意：只有相同类型的指针才可以互相赋值（`void *` 类型的除外）。

```c
#include <stdio.h>

int main() {

    int a = 100;
    int *p, *q;
    p = &a;
    printf("a = %d %d\n", a, *p);
    q = p;
    printf("*q = %d\n", *q);
    *q = 999;
    printf("a = %d\n", a);

    return 0;
}
```

输出结果：

![image](https://github.com/XinranSix/docs/assets/62458905/06eaf1c8-1cb9-4b39-9819-8302fb3a1b4b)

## 指针数组

指针可以保存数组元素的地址，也可以定义一个数组，数组中的元素是若干个相同类型的指针变量，这个数组就是**指针数组**。

定义指针数组的语法：

```c
类型说明符 *数组名[元素个数];
```

例如：

```c
int *p[10];
int a;
p[1] = &a;
int b[10];
p[2] = &b[3];
// p[2] 和 *(p + 2) 是等价的，都是指针数组中的第 2 个元素。
```

指针数组按照其元素进行分类。

```c
#include <stdio.h>

int main() {

    char *name[5] = {"Follw me", "BASIC", "Greatwall", "FORTRAN", "Computer"};
    int i;
    for (i = 0; i < 5; i++) {
        printf("%s\n", name[i]);
    }
    return 0;
}
```

输出结果：

![image](https://github.com/XinranSix/docs/assets/62458905/f14afb71-5e32-4fc7-8753-45f8e5e3d07d)

## 指针的指针

指针的指针又称为二级指针。

指针本身也是一个变量，也有地址，可以用二级指针保存其地址。

```c
#include <stdio.h>

int main(int argc, char *argv[]) {

    int a = 100;
    int *p = &a;
    int **q = &p;

    printf("a = %d %d %d\n", a, *p, **q);
    printf("&a = %p %p %p\n", &a, p, *q);
    printf("&p = %p %p\n", &p, q);
    printf("&q = %p\n", &q);

    return 0;
}
```

输出结果：

![image](https://github.com/XinranSix/docs/assets/62458905/beb44686-257b-4683-9fdc-00174129116e)

## 字符串和指针

在 C 语言中，字符串是以 `'\0'` 结尾的若干字符的集合。

字符串的存储形式：数组、字符串指针、堆。

1. `char string[100] = "I love C!";`， 定义了一个字符数组 `string`，用来存放多个字符，并且使用 `I love C!\0` 给 `string` 数组初始化。
2. `char *str = "I love C!"`，定义了一个指针变量 `str`，这个字符串中的字符不能存放在 `str` 变量中，`str` 只存放了字符 `I` 的地址，`"I love C!"` 存放在文字常量区。
3. `char *str = (char*)malloc(10 * sizeof(char));`，动态申请了 10 个字节的存储空间，使用首地址个给 `str` 赋值，可以使用 `strcpy(str, "I love C")` 的方式将字符串 `"I love C!"` 拷贝到 `str` 指向的内存中。

**可修改性：**

1. 栈区和全局区内存中的内容是可修改的。

```c
char str[100] = "I love C!";
str[0] = 'y'; // 这是 ok 的
```

2. 文字常量区的内容是不可修改的。

```c
char *str = "I love C!";
*str = 'y'; // 这是不行的
```

3. 堆区的内容是可以修改的。

```c
char *str = (char*)malloc(10 * sizeof(char));
```



## 数组指针

## 指针与函数的关系

## 经常容易混淆的指针

## 特殊指针

## main 函数传参